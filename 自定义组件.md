# AI 自定义组件开发提示语文档

## 1. 项目架构概述

### 1.1 整体目录结构
```
project-root/
├── src/
│   ├── components/          # 所有自定义组件存放目录
│   │   ├── ComponentName/   # 组件名称目录（ PascalCase 命名）
│   │   │   ├── index.tsx    # 组件入口，暴露 Props 和组件
│   │   │   ├── ComponentName.tsx   # 组件核心逻辑
│   │   │   ├── ComponentName.styles.ts   # 组件样式
│   │   │   ├── ComponentName.types.ts    # 类型定义
│   │   │   ├── ComponentName.utils.ts    # 工具函数
│   │   │   └── ComponentName.test.tsx    # 组件测试
│   │   └── index.ts         # 统一导出所有组件
│   ├── App.tsx              # 应用入口
│   └── main.tsx             # 应用启动文件
├── package.json
├── tsconfig.json
└── vite.config.ts           # 构建配置
```

### 1.2 组件目录规范
- **组件名称**：使用 PascalCase 命名法（如 `Button`, `InputField`）
- **组件目录**：每个组件必须有独立的目录，与组件名称一致
- **文件命名**：组件相关文件使用组件名称前缀（如 `Button.tsx`, `Button.styles.ts`）

## 2. 组件开发规范

### 2.1 组件入口文件 (`index.tsx`)
- 必须暴露组件的 Props 类型和组件本身
- 使用 `export` 关键字导出
- 保持简洁，仅包含导出逻辑


### 2.2 组件核心文件 (`ComponentName.tsx`)
- 实现组件的主要逻辑和渲染
- 使用函数组件（优先使用 React Hooks）
- 严格遵循 Props 类型定义

### 2.4 样式文件 (`ComponentName.styles.ts`)
- 使用 CSS-in-JS 方案（如 Styled Components, Emotion）
- 或使用模块化 CSS（如 `.module.css`）
- 样式逻辑与组件分离
- 支持主题和变体

### 2.5 工具函数文件 (`ComponentName.utils.ts`)
- 存放组件相关的辅助函数
- 与组件逻辑分离，提高可维护性
- 支持单元测试

**示例：**
```typescript
// components/Button/Button.utils.ts
export const handleClick = (e: React.MouseEvent<HTMLButtonElement>) => {
  // 通用点击处理逻辑
  console.log('Button clicked:', e.currentTarget.textContent);
};

export const validateButtonProps = (props: any) => {
  // 验证按钮属性的辅助函数
  if (!props.children) {
    console.warn('Button should have children');
  }
};
```

### 2.6 测试文件 (`ComponentName.test.tsx`)
- 使用 Jest 和 React Testing Library 进行测试
- 测试组件的各种状态和交互
- 确保组件的稳定性和可靠性

**示例：**
```typescript
// components/Button/Button.test.tsx
import React from 'react';
import { render, screen, fireEvent } from '@testing-library/react';
import { Button } from './Button';

describe('Button Component', () => {
  test('renders with children', () => {
    render(<Button>Click Me</Button>);
    expect(screen.getByText('Click Me')).toBeInTheDocument();
  });

  test('handles click events', () => {
    const handleClick = jest.fn();
    render(<Button onClick={handleClick}>Click Me</Button>);
    fireEvent.click(screen.getByText('Click Me'));
    expect(handleClick).toHaveBeenCalledTimes(1);
  });

  test('renders with different variants', () => {
    render(
      <>
        <Button variant="primary">Primary</Button>
        <Button variant="secondary">Secondary</Button>
        <Button variant="outline">Outline</Button>
      </>
    );
    expect(screen.getByText('Primary')).toBeInTheDocument();
    expect(screen.getByText('Secondary')).toBeInTheDocument();
    expect(screen.getByText('Outline')).toBeInTheDocument();
  });
});
```

## 3. Props 管理规范

### 3.1 Props 设计原则
- **单一职责**：每个 Props 只负责一个功能
- **默认值**：为可选 Props 提供合理的默认值
- **类型安全**：使用 TypeScript 严格定义 Props 类型
- **文档化**：为每个 Props 添加 JSDoc 注释

### 3.2 Props 分类
- **功能性 Props**：控制组件行为（如 `onClick`, `disabled`）
- **展示性 Props**：控制组件样式（如 `variant`, `size`）
- **数据 Props**：传递给组件的数据（如 `value`, `options`）
- **事件 Props**：处理组件事件（如 `onChange`, `onSubmit`）

## 4. 组件逻辑处理

### 4.1 逻辑封装原则
- **组件内聚**：所有组件相关的逻辑必须在组件目录内处理
- **逻辑分离**：将复杂逻辑拆分为多个函数或文件
- **可测试性**：逻辑函数应该易于单元测试
- **可复用性**：通用逻辑可以提取到工具函数中

### 4.2 状态管理
- 使用 React Hooks 管理组件状态（如 `useState`, `useEffect`）
- 复杂状态可以使用状态管理库（如 Zustand, Redux）
- 避免在组件内处理全局状态（除非必要）

### 4.3 副作用处理
- 使用 `useEffect` Hook 处理副作用
- 确保清理函数正确实现，避免内存泄漏
- 控制依赖项数组，避免不必要的重渲染

## 5. 组件导出与使用

### 5.1 统一导出 (`components/index.ts`)
- 从每个组件的入口文件导入并重新导出
- 提供统一的组件访问入口
- 简化组件的导入路径

**示例：**
```typescript
// components/index.ts
export { Button, type ButtonProps } from './Button';
export { InputField, type InputFieldProps } from './InputField';
export { Card, type CardProps } from './Card';
```

### 5.2 组件使用
- 从统一导出文件导入组件和 Props 类型
- 使用类型安全的方式传递 Props
- 遵循组件的使用说明

## 6. 开发流程

### 6.1 创建新组件
1. 在 `components` 目录下创建组件目录
2. 创建组件所需的文件（`index.tsx`, `ComponentName.tsx`, `ComponentName.types.ts` 等）
3. 实现组件逻辑和样式
4. 编写单元测试
5. 导出组件到 `components/index.ts`

### 6.2 组件测试
1. 运行单元测试：`npm test`
2. 确保所有测试通过
3. 测试组件的各种状态和边界情况

### 6.3 组件发布
1. 确保组件符合开发规范
2. 更新版本号
3. 发布到包管理器

## 7. 最佳实践

### 7.1 性能优化
- 使用 `React.memo` 避免不必要的重渲染
- 使用 `useCallback` 和 `useMemo` 缓存函数和计算结果
- 延迟加载大型组件
- 避免在渲染过程中创建新函数

### 7.2 可访问性 (a11y)
- 确保组件符合 WCAG 标准
- 使用正确的 HTML 语义化标签
- 提供适当的 ARIA 属性
- 支持键盘导航

### 7.3 国际化 (i18n)
- 支持多语言
- 使用国际化库（如 i18next）
- 将文本内容与组件逻辑分离

### 7.4 主题支持
- 支持自定义主题
- 使用 CSS 变量或主题上下文
- 提供默认主题

## 8. 常见问题与解决方案

### 8.1 组件命名冲突
- **问题**：组件名称与第三方库冲突
- **解决方案**：使用命名空间或前缀

### 8.2 组件性能问题
- **问题**：组件渲染缓慢
- **解决方案**：使用性能优化技术（如 `React.memo`, `useMemo`）

### 8.3 组件测试困难
- **问题**：组件难以测试
- **解决方案**：分离逻辑和渲染，使用测试工具库

## 9. 附录

### 9.1 技术栈推荐
- **框架**：React 18+
- **语言**：TypeScript
- **构建工具**：Vite
- **样式方案**：CSS-in-JS (Emotion, Styled Components) 或 CSS Modules
- **测试框架**：Jest, React Testing Library
- **状态管理**：Zustand (轻量级) 或 Redux (复杂应用)

### 9.2 相关资源
- [React 官方文档](https://react.dev/)
- [TypeScript 官方文档](https://www.typescriptlang.org/docs/)
- [Vite 官方文档](https://vitejs.dev/guide/)
- [React Testing Library 文档](https://testing-library.com/docs/react-testing-library/intro/)

